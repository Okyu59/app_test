import os import re import math from collections import Counter from datetime import datetime, timedelta import matplotlib.pyplot as plt import pandas as pd import plotly.express as px import streamlit as st from google_play_scraper import Sort, reviews from wordcloud import WordCloud # --------------------------------------------------------- # ê¸°ë³¸ ì„¤ì • # --------------------------------------------------------- st.set_page_config( page_title="ëª¨ë‹ˆëª¨ ë¦¬ë·° ëŒ€ì‹œë³´ë“œ", layout="wide", initial_sidebar_state="collapsed", ) APP_ID = "net.ib.android.smcard" # ëª¨ë‹ˆëª¨ íŒ¨í‚¤ì§€ëª… # --------------------------------------------------------- # ì „ì—­ CSS + Iconify ìŠ¤í¬ë¦½íŠ¸ â€“ ìµœëŒ€ ê°€ë¡œí­ / KPI ì¹´ë“œ / í‚¤ì›Œë“œ ë±ƒì§€ / ë¦¬ë·° ì¹´ë“œ / ì• ë‹ˆë©”ì´ì…˜ # --------------------------------------------------------- st.markdown( """ <!-- Iconify Solar Duotone Bold Icons --> <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.min.js"></script> <style> body { background-color: #f5f7fb; } /* âœ… ìµœëŒ€ ê°€ë¡œí­ 1600px, ê°€ìš´ë° ì •ë ¬ */ .block-container { padding-top: 1.5rem; padding-bottom: 2rem; max-width: 1600px; margin-left: auto; margin-right: auto; } /* ìƒë‹¨ í—¤ë”: ë¡œê³  + íƒ€ì´í‹€ ë ˆì´ì•„ì›ƒ */ .header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; } .logo-title { display: flex; align-items: center; gap: 12px; } .logo-title img { width: 40px; height: 40px; border-radius: 10px; } /* í‚¤í”„ë ˆì„ ì• ë‹ˆë©”ì´ì…˜ */ @keyframes fadeInUp { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } } /* KPI ì¹´ë“œ */ .kpi-wrapper { display: flex; flex-wrap: wrap; gap: 16px; margin-bottom: 16px; } .kpi-card { flex: 1; min-width: 200px; padding: 22px 22px; /* ë†’ì´ ì¡°ê¸ˆ ë” í‚¤ì›€ */ border-radius: 20px; color: #ffffff; box-shadow: 0 16px 40px rgba(15, 23, 42, 0.18); position: relative; overflow: hidden; animation: fadeInUp 0.4s ease-out; transition: transform 0.18s ease-out, box-shadow 0.18s ease-out; } .kpi-card:hover { transform: translateY(-2px); box-shadow: 0 18px 45px rgba(15, 23, 42, 0.25); } .kpi-title { font-size: 14px; opacity: 0.9; margin-bottom: 4px; } .kpi-value { font-size: 30px; font-weight: 700; margin-bottom: 8px; } .kpi-sub { font-size: 12px; opacity: 0.85; } /* ê° KPI ì¹´ë“œë³„ ê·¸ë¼ë°ì´ì…˜ */ .kpi-avg-score { background: linear-gradient(135deg, #6366f1, #8b5cf6); } .kpi-total-reviews { background: linear-gradient(135deg, #ec4899, #f97316); } .kpi-negative-ratio { background: linear-gradient(135deg, #f97373, #ef4444); } /* âœ… ê¸ì • ë¦¬ë·° ë¹„ìœ¨ ì¹´ë“œ â€“ íŒŒë€ìƒ‰ ê³„ì—´ */ .kpi-positive-ratio { background: linear-gradient(135deg, #0ea5e9, #2563eb); } /* ì¹´ë“œ ê³µí†µ */ .card { background: #ffffff; padding: 18px 22px; border-radius: 18px; box-shadow: 0 8px 24px rgba(15, 23, 42, 0.08); margin-bottom: 18px; animation: fadeInUp 0.4s ease-out; transition: transform 0.18s ease-out, box-shadow 0.18s ease-out; } .card:hover { transform: translateY(-1px); box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12); } /* í‚¤ì›Œë“œ ë±ƒì§€ */ .keyword-badge { display: inline-block; padding: 6px 12px; margin: 4px; border-radius: 999px; font-size: 13px; font-weight: 600; border: 1px solid transparent; } .badge-positive { background: #e5f6ea; color: #137333; border-color: rgba(19, 115, 51, 0.25); } .badge-negative { background: #feecec; color: #b80606; border-color: rgba(184, 6, 6, 0.25); } /* ë¦¬ë·° ë¦¬ìŠ¤íŠ¸ â€“ í˜ì´ì§€ë„¤ì´ì…˜ìš© ì˜ì—­ */ .review-list { max-height: 650px; overflow-y: auto; padding-right: 4px; } .review-card { background: #ffffff; padding: 14px 16px; border-radius: 14px; margin-bottom: 10px; box-shadow: 0 4px 16px rgba(15, 23, 42, 0.06); animation: fadeInUp 0.35s ease-out; transition: transform 0.16s ease-out, box-shadow 0.16s ease-out; } .review-card:hover { transform: translateY(-1px); box-shadow: 0 8px 26px rgba(15, 23, 42, 0.14); } .review-header { display: flex; justify-content: space-between; align-items: center; font-size: 12px; margin-bottom: 6px; color: #6b7280; } .review-user { font-weight: 600; color: #111827; display: inline-flex; align-items: center; gap: 4px; } .review-score { font-weight: 600; color: #f59e0b; } .review-content { color: #374151; font-size: 13px; line-height: 1.5; white-space: pre-wrap; } /* í˜ì´ì§€ë„¤ì´ì…˜ í…ìŠ¤íŠ¸ ì¤‘ì•™ì •ë ¬ */ .pagination-info { text-align: center; font-size: 13px; color: #4b5563; margin-top: 4px; margin-bottom: 8px; } </style> """, unsafe_allow_html=True, ) # --------------------------------------------------------- # 1. ë°ì´í„° ìˆ˜ì§‘ (ìºì‹œ) # --------------------------------------------------------- @st.cache_data(ttl=3600) def get_reviews(days: int = 7) -> pd.DataFrame: """ìµœê·¼ Nì¼ê°„ì˜ Google Play ë¦¬ë·°ë¥¼ ìˆ˜ì§‘.""" result, _ = reviews( APP_ID, lang="ko", country="kr", sort=Sort.NEWEST, count=300, ) df = pd.DataFrame(result) df["at"] = pd.to_datetime(df["at"]) cutoff_date = datetime.now() - timedelta(days=days) recent_df = df[df["at"] >= cutoff_date].copy() return recent_df # --------------------------------------------------------- # 2. í…ìŠ¤íŠ¸ í† í°í™” & í‚¤ì›Œë“œ ì¶”ì¶œ (ìˆœìˆ˜ íŒŒì´ì¬, 1ë‹¨ì–´ ê¸°ì¤€) # --------------------------------------------------------- KOREAN_STOPWORDS = set( [ "ëª¨ë‹ˆëª¨", "ì‚¼ì„±ì¹´ë“œ", "ì•±", "ì–´í”Œ", "ì‚¬ìš©", "ì´", "ê·¸", "ì €", "ê²ƒ", "ìˆ˜", "ë•Œ", "ìê¾¸", "ì™œ", "ì¢€", "í•´", "ë”", "í•¨", "ì •ë„", "ê·¸ë¦¬ê³ ", "ê·¸ëƒ¥", "ì§„ì§œ", "ë³´ê³ ", "í•´ì„œ", "í•˜ë©´", "ì´ë²ˆ", "ìµœê·¼", "ê±°ì˜", "ê³„ì†", "ë§¤ìš°", "ì´í›„", "ì´í›„ë¡œ", "ì´í›„ì—", # âœ… ìƒˆë¡œ ì œí•œí•  ë‹¨ì–´ë“¤ "ë‹¤ì‹œ", "ë„ˆë¬´", "í•˜ê³ ", "í•˜ê¸°", "ë‹¤ë¥¸", "ì •ë§", "ë¬´ìŠ¨", "ì´ë ‡ê²Œ", "ì—†ê³ ", "ëˆ„ë¥´ë©´" ] ) def tokenize_korean(text: str): """í•œê¸€/ìˆ«ì ìœ„ì£¼ë¡œ í† í°í™” & 2ê¸€ì ì´ìƒ ë‹¨ì–´ë§Œ ì‚¬ìš©.""" text = re.sub(r"[^ê°€-í£0-9\s]", " ", text) text = re.sub(r"\s+", " ", text).strip() if not text: return [] tokens = text.split() tokens = [ t for t in tokens if len(t) >= 2 and t not in KOREAN_STOPWORDS and not t.isdigit() ] return tokens def extract_unigrams(text_series: pd.Series) -> Counter: """ë‹¨ì–´(ìœ ë‹ˆê·¸ë¨) ë¹ˆë„.""" all_tokens = [] for t in text_series.dropna().astype(str): all_tokens.extend(tokenize_korean(t)) return Counter(all_tokens) # --------------------------------------------------------- # 3. WordCloudìš© í°íŠ¸ ê²½ë¡œ íƒìƒ‰ # --------------------------------------------------------- def get_korean_font_path(): base_dir = os.path.dirname(os.path.abspath(__file__)) candidates = [ os.path.join(base_dir, "NanumGothic.ttf"), os.path.join(base_dir, "NotoSansKR-Regular.otf"), "/System/Library/Fonts/AppleGothic.ttf", "/Library/Fonts/AppleGothic.ttf", "/usr/share/fonts/truetype/nanum/NanumGothic.ttf", "/usr/share/fonts/truetype/noto/NotoSansCJK-Regular.ttc", "malgun.ttf", ] for path in candidates: if os.path.exists(path): return path return None FONT_PATH = get_korean_font_path() # --------------------------------------------------------- # 4. UI ë Œë”ë§ í•¨ìˆ˜ë“¤ # --------------------------------------------------------- def render_kpi_cards(avg_score, total_reviews, negative_ratio, positive_ratio): """ìƒë‹¨ KPI ì¹´ë“œ 4ê°œ ë Œë”ë§.""" html = f""" <div class="kpi-wrapper"> <div class="kpi-card kpi-avg-score"> <div class="kpi-title">í‰ê·  í‰ì </div> <div class="kpi-value">{avg_score:.2f} â­</div> <div class="kpi-sub">ì„ íƒí•œ ê¸°ê°„ ê¸°ì¤€ í‰ê·  ì•± í‰ì </div> </div> <div class="kpi-card kpi-total-reviews"> <div class="kpi-title">ì´ ë¦¬ë·° ìˆ˜</div> <div class="kpi-value">{total_reviews} ê±´</div> <div class="kpi-sub">ì„ íƒí•œ ê¸°ê°„ ë™ì•ˆ ìˆ˜ì§‘ëœ ë¦¬ë·° ìˆ˜</div> </div> <div class="kpi-card kpi-negative-ratio"> <div class="kpi-title">ë¶€ì • ë¦¬ë·° ë¹„ìœ¨</div> <div class="kpi-value">{negative_ratio:.1f}%</div> <div class="kpi-sub">1~2ì  ë¦¬ë·° ë¹„ì¤‘</div> </div> <div class="kpi-card kpi-positive-ratio"> <div class="kpi-title">ê¸ì • ë¦¬ë·° ë¹„ìœ¨</div> <div class="kpi-value">{positive_ratio:.1f}%</div> <div class="kpi-sub">4~5ì  ë¦¬ë·° ë¹„ì¤‘</div> </div> </div> """ st.markdown(html, unsafe_allow_html=True) def render_keyword_badges(counter_obj: Counter, positive: bool = True): """Top10 í‚¤ì›Œë“œë¥¼ ë±ƒì§€ í˜•íƒœë¡œ ë Œë”ë§ (1ë‹¨ì–´ ê¸°ì¤€).""" style_class = "badge-positive" if positive else "badge-negative" if not counter_obj: st.write("í‚¤ì›Œë“œê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.") return items = counter_obj.most_common(10) # âœ… 10ê°œ ë…¸ì¶œ badges = "".join( f"<span class='keyword-badge {style_class}'>{k} ({v})</span>" for k, v in items ) st.markdown(f"<div class='card'>{badges}</div>", unsafe_allow_html=True) def render_review_list(df_page: pd.DataFrame): """í˜„ì¬ í˜ì´ì§€ì— í•´ë‹¹í•˜ëŠ” ë¦¬ë·° ì¹´ë“œ ë¦¬ìŠ¤íŠ¸.""" st.markdown("<div class='review-list'>", unsafe_allow_html=True) for _, row in df_page.iterrows(): user = row.get("userName", "ìµëª… ì‚¬ìš©ì") or "ìµëª… ì‚¬ìš©ì" score = row.get("score", "-") content = row.get("content", "") date_str = row["at"].strftime("%Y-%m-%d") # âœ… Solar Duotone Bold user icon ì ìš© card_html = f""" <div class="review-card"> <div class="review-header"> <span class="review-user"> <iconify-icon icon="solar:user-bold-duotone" style="font-size:16px;"></iconify-icon> {user} </span> <span class="review-score">â­ {score}</span> </div> <div class="review-header" style="margin-bottom:4px;"> <span>{date_str}</span> </div> <div class="review-content">{content}</div> </div> """ st.markdown(card_html, unsafe_allow_html=True) st.markdown("</div>", unsafe_allow_html=True) # --------------------------------------------------------- # 5. ë©”ì¸ ì•± # --------------------------------------------------------- def main(): # âœ… ì„¤ì •ê°’ ì´ˆê¸°í™” (ë¶„ì„ ê¸°ê°„ / í˜ì´ì§€ ë²ˆí˜¸) if "days" not in st.session_state: st.session_state["days"] = 7 if "page" not in st.session_state: st.session_state["page"] = 1 # ---------- ìƒë‹¨ í—¤ë” + ìš°ì¸¡ ì„¤ì • ì•„ì´ì½˜ (popover) ---------- with st.container(): st.markdown('<div class="header-row">', unsafe_allow_html=True) left_col, right_col = st.columns([0.8, 0.2]) with left_col: # âœ… ëª¨ë‹ˆëª¨ ë¡œê³  + íƒ€ì´í‹€ st.markdown( """ <div class="logo-title"> <img src="https://play-lh.googleusercontent.com/g-tkfYaRAe0u_DqUAtk4ETg0nl3ZoJIrntTC_K-A4WmpeP-yQi80IHsugmpMEGm9qWCD82HbeeyI-tYQsH1YKg" alt="ëª¨ë‹ˆëª¨ ë¡œê³ " /> <div> <h1 style="margin-bottom:2px;">ëª¨ë‹ˆëª¨ í”Œë ˆì´ìŠ¤í† ì–´ ë¦¬ë·° ëŒ€ì‹œë³´ë“œ</h1> <p style="margin-top:0; color:#6b7280; font-size:13px;"> Google Play ë¦¬ë·°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ëª¨ë‹ˆëª¨ ì•±ì˜ ì‚¬ìš©ì ë°˜ì‘ì„ ë¶„ì„í•©ë‹ˆë‹¤. </p> </div> </div> """, unsafe_allow_html=True, ) with right_col: # âœ… ìš°ìƒë‹¨ ì„¤ì • ì•„ì´ì½˜ + íŒì—… (ë¶„ì„ ì˜µì…˜) with st.popover("âš™ï¸ ì„¤ì •", use_container_width=False): st.write("ë¶„ì„ ì˜µì…˜") st.session_state["days"] = st.slider( "ìµœê·¼ Nì¼ ê¸°ì¤€", min_value=3, max_value=30, value=st.session_state["days"], step=1, ) st.markdown("</div>", unsafe_allow_html=True) days = st.session_state["days"] st.markdown( f"**ë¶„ì„ ê¸°ê°„:** ìµœê·¼ {days}ì¼ ({(datetime.now() - timedelta(days=days)):%Y-%m-%d} ~ {datetime.now():%Y-%m-%d})" ) # ---------- ë°ì´í„° ë¡œë“œ ---------- with st.spinner("Google Play ë¦¬ë·°ë¥¼ ìˆ˜ì§‘í•˜ëŠ” ì¤‘ì…ë‹ˆë‹¤..."): try: df = get_reviews(days) except Exception as e: st.error(f"ë°ì´í„° ìˆ˜ì§‘ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}") return if df.empty: st.warning("ì„ íƒí•œ ê¸°ê°„ ë™ì•ˆ ì‘ì„±ëœ ë¦¬ë·°ê°€ ì—†ê±°ë‚˜ ìˆ˜ì§‘ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.") return # KPI ê³„ì‚° avg_score = df["score"].mean() total_reviews = len(df) negative_cnt = len(df[df["score"] <= 2]) positive_cnt = len(df[df["score"] >= 4]) negative_ratio = negative_cnt / total_reviews * 100 positive_ratio = positive_cnt / total_reviews * 100 # ---------- KPI ì¹´ë“œ ---------- render_kpi_cards(avg_score, total_reviews, negative_ratio, positive_ratio) # ---------- ì¢Œ/ìš° ë ˆì´ì•„ì›ƒ ---------- left_col, right_col = st.columns([0.6, 0.4], gap="large") # ----- ì¢Œì¸¡: ì¶”ì´ + í‚¤ì›Œë“œ ----- with left_col: st.subheader("ğŸ“ˆ ì¼ë³„ í‰ê·  í‰ì  ì¶”ì´") daily_df = ( df.groupby(df["at"].dt.date)["score"].mean().reset_index(name="score") ) daily_df.rename(columns={"at": "date"}, inplace=True) fig_line = px.line( daily_df, x="date", y="score", markers=True, labels={"date": "ë‚ ì§œ", "score": "í‰ì "}, ) fig_line.update_traces(line_shape="spline", line={"width": 4}) fig_line.update_yaxes(range=[0.5, 5.5]) fig_line.update_layout( height=320, plot_bgcolor="#ffffff", margin=dict(l=20, r=20, t=30, b=30), ) st.plotly_chart(fig_line, use_container_width=True) st.markdown("---") st.subheader("ğŸ”‘ ì£¼ìš” í‚¤ì›Œë“œ ë¶„ì„") positive_reviews = df[df["score"] >= 4]["content"] negative_reviews = df[df["score"] <= 2]["content"] tab_neg, tab_pos = st.tabs(["ğŸ”¥ ë¶€ì • ë¦¬ë·°", "ğŸ€ ê¸ì • ë¦¬ë·°"]) # ----- ë¶€ì • ë¦¬ë·° íƒ­ ----- with tab_neg: if not negative_reviews.empty: neg_unigrams = extract_unigrams(negative_reviews) st.markdown("**Top 10 ë¶€ì • í‚¤ì›Œë“œ**") render_keyword_badges(neg_unigrams, positive=False) st.markdown("**Word Cloud**") if FONT_PATH is None: st.info("í•œê¸€ í°íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ WordCloudê°€ ê¹¨ì ¸ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (NanumGothic.ttf ë“±ì„ í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— ì¶”ê°€í•˜ë©´ í•´ê²°ë©ë‹ˆë‹¤.)") wc = WordCloud( font_path=FONT_PATH, background_color="white", width=800, height=300, ).generate_from_frequencies(neg_unigrams) fig, ax = plt.subplots(figsize=(8, 3)) ax.imshow(wc, interpolation="bilinear") ax.axis("off") st.pyplot(fig) plt.close(fig) else: st.info("ë¶€ì • ë¦¬ë·°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.") # ----- ê¸ì • ë¦¬ë·° íƒ­ ----- with tab_pos: if not positive_reviews.empty: pos_unigrams = extract_unigrams(positive_reviews) st.markdown("**Top 10 ê¸ì • í‚¤ì›Œë“œ**") render_keyword_badges(pos_unigrams, positive=True) st.markdown("**Word Cloud**") if FONT_PATH is None: st.info("í•œê¸€ í°íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ì–´ WordCloudê°€ ê¹¨ì ¸ ë³´ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (NanumGothic.ttf ë“±ì„ í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— ì¶”ê°€í•˜ë©´ í•´ê²°ë©ë‹ˆë‹¤.)") wc_pos = WordCloud( font_path=FONT_PATH, background_color="white", width=800, height=300, ).generate_from_frequencies(pos_unigrams) fig2, ax2 = plt.subplots(figsize=(8, 3)) ax2.imshow(wc_pos, interpolation="bilinear") ax2.axis("off") st.pyplot(fig2) plt.close(fig2) else: st.info("ê¸ì • ë¦¬ë·°ê°€ ì¶©ë¶„í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.") # ----- ìš°ì¸¡: ë¦¬ë·° ë¦¬ìŠ¤íŠ¸ + í˜ì´ì§€ë„¤ì´ì…˜ ----- with right_col: st.subheader("ğŸ“ ë¦¬ë·° ì›ë¬¸ ë³´ê¸°") df_sorted = df[["userName", "score", "content", "at"]].sort_values( by="at", ascending=False ) page_size = 15 total = len(df_sorted) max_page = max(1, math.ceil(total / page_size)) # í˜„ì¬ í˜ì´ì§€ê°€ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ì§€ ì•Šê²Œ ë³´ì • if st.session_state["page"] > max_page: st.session_state["page"] = max_page if st.session_state["page"] < 1: st.session_state["page"] = 1 col_prev, col_info, col_next = st.columns([1, 2, 1]) with col_prev: if st.button("â¬… ì´ì „", disabled=(st.session_state["page"] <= 1)): st.session_state["page"] -= 1 with col_next: if st.button("ë‹¤ìŒ â¡", disabled=(st.session_state["page"] >= max_page)): st.session_state["page"] += 1 with col_info: st.markdown( f"<div class='pagination-info'>í˜ì´ì§€ {st.session_state['page']} / {max_page} (ì´ {total}ê°œ)</div>", unsafe_allow_html=True, ) start = (st.session_state["page"] - 1) * page_size end = start + page_size df_page = df_sorted.iloc[start:end] render_review_list(df_page) if __name__ == "__main__": main()
